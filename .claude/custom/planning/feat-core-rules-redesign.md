# Core Rules Redesign

## Problem 1: Request Type Classification
**Solution:** Updated 3-category system with clearer terminology for mode-based workflow:

**KNOWLEDGE REQUESTS (unchanged):**
- Purpose: General programming concepts, explanations, comparisons
- Indicators: "what is", "how does", "explain", "difference between", programming theory
- Behavior: Answer as normal LLM without codebase access

**MODE-WORKFLOW REQUESTS (renamed from Coding-Workflow):**
- Purpose: Structured development tasks requiring mode-based workflow
- Indicators: Mode keywords - "planning", "implement", "tasks", "skeleton", "project overview"
- Behavior: Must detect mode and load appropriate mode prompt

**CODE-ANALYSIS REQUESTS (refined):**
- Purpose: Direct analysis of existing code without workflow
- Indicators: "analyze", "understand", "debug", "what does this do", "how does this work"
- Behavior: Load available docs, scan codebase, provide analysis

**Enhanced Detection Logic:**
- Clear mode keywords for workflow detection
- Simplified classification flow with priority-based detection
- User-friendly options when request type unclear

## Problem 2: Mode Detection Logic
**Solution:** Streamlined mode-based detection replacing complex step system:

**Simplified Mode Detection Keywords:**
- "project overview" → project-overview.md
- "planning" / "planning tasks" / "planning skeleton" → planning.md (with variants)
- "tasks" / "tasks skeleton" → tasks.md (with variants)
- "skeleton" → skeleton.md (always dual mode)
- "implement" → implement.md (context-dependent)
- "standalone implement" / "quick implement" → standalone-implement.md

**4-Step Execution Protocol:**
1. DETECT MODE: Identify mode from user keywords
2. CHECK PROMPT: Verify mode guide prompt exists in context
3. IF FOUND: Proceed with mode execution
4. IF NOT FOUND: Request prompt loading

**Variant Detection:** Base mode + modifier = variant (planning + tasks = dual mode)
**Context Dependencies:** Clear validation for dependent modes (tasks needs planning, implement needs all)

## Problem 3: Context Loading Strategy
**Solution:** Session-aware loading with mode-specific requirements and inheritance:

**Updated Documentation Structure:**
- docs/: 4 core files (BUSINESS-CONTEXT, ARCHITECTURE, CODEBASE-MAP, PATTERNS-CONVENTIONS)
- .claude/custom/: workflow files (planning/, tasks/)

**Mode-Specific Loading Requirements:**
- project-overview: Creates all 4 docs
- planning: BUSINESS-CONTEXT + ARCHITECTURE (+ CODEBASE-MAP for dual/triple)
- tasks: Planning file + CODEBASE-MAP + PATTERNS-CONVENTIONS
- skeleton: Inherits from parent mode + PATTERNS-CONVENTIONS
- implement: All context (planning + tasks + skeleton + 4 docs)
- standalone-implement: Auto-load CODEBASE-MAP + PATTERNS-CONVENTIONS

**Session-Aware Protocol:**
- Check if docs already loaded in session
- Skip redundant loading with notification
- Context inheritance for dual/triple modes
- Graceful handling of missing files with fallbacks

## Problem 4: Quality Standards Consolidation
**Solution:** Essential universal standards with mode-specific details delegated to mode prompts:

**Essential Code Quality (Core Requirements):**
- Structure: Single responsibility, clear separation, consistent naming
- Error Handling: Comprehensive try-catch, structured logging, proper transformation
- Documentation: Method docs with parameters/returns, business context, TODO comments

**Security Essentials (Universal Requirements):**
- Input Security: Validate/sanitize inputs, parameterized queries, no sensitive logging
- Authentication: Follow project patterns, validate permissions, audit logging
- Data Protection: No committed secrets, encrypt sensitive data, secure passwords

**Performance Guidelines (Practical Standards):**
- Efficiency: Avoid N+1 problems, proper async/await, resource cleanup
- Monitoring: Performance timing, slow operation logging, resource monitoring

**Simplified Quality Validation:**
- Essential checklist for all modes (code quality, security, integration)
- Implementation-specific checklist for implement modes only
- Removed overly detailed checklists (moved to mode prompts)

## Problem 5: File Management Standards
**Solution:** Unified file organization and naming standards across all modes:

**Standard Directory Layout:**
- docs/: Project documentation (4 core files)
- .claude/custom/planning/: Planning documents
- .claude/custom/tasks/: Task breakdown files (mirror planning names)
- src/: Implementation code (generated by skeleton/implement)

**Universal Naming Standards:**
- Pattern: [type]-[feature-name].md
- Types: feat-, bugfix-, refactor-, enhance-, update-
- File relationships: Planning and tasks files use exact same name

**Unified Confirmation Protocol:**
1. Auto-suggest filename based on content
2. Present suggestion with confirmation request
3. Wait for explicit confirmation (never proceed without)
4. Validate naming pattern and handle conflicts
5. Create file in appropriate directory

**Cross-Mode File Coordination:**
- Auto-reference management between related files
- Session file tracking for efficient operations
- Status preservation and smart update strategies

## Problem 6: Outdated Content Removal
**Solution:** Eliminate step-based complexity and focus on essential universal guidelines:

**REMOVED Completely:**
- All step-based terminology (step-planning, step-5-implement, etc.)
- Complex 7-step execution protocol and step dependency checking
- Outdated documentation references (PROJECT-OVERVIEW.md, CODING-STANDARDS.md)
- Detailed quality checklists (moved to mode prompts)
- Technology-specific guidelines and complex protocols

**KEPT Essential Universal Rules:**
- Anti-hallucination guidelines (unchanged)
- Request type detection (updated terminology)
- Mode detection and execution (simplified)
- Essential quality standards (consolidated)
- Basic file management standards (unified)
- Decision making guidelines (unchanged)

**Content Migration Strategy:**
- Detailed requirements moved to individual mode prompts
- Core rules focus on universal principles only
- Reduced from 121 lines to ~60-70 lines
- Clear separation between core rules and mode-specific guidance

**Benefits:**
- Clarity: Focus on essential universal principles
- Maintainability: Smaller, focused core rules
- Usability: Faster to understand and process
- Performance: Lighter rules with clear escalation to mode prompts